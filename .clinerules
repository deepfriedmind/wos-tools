# Nuxt 3 Development & Testing Guide

## Project Overview

This project is built with Nuxt 3, Vue 3, TypeScript, Tailwind CSS, and PrimeVue. It follows a modular architecture pattern with proper separation of concerns across directories.

## Architecture Overview

```mermaid
graph TB
    subgraph Nuxt3 Application
        subgraph Core
            Composables[Composables<br/>composables/]
            Components[Components<br/>components/]
            Layouts[Layouts<br/>layouts/]
            Pages[Pages<br/>pages/]
            Utils[Utilities<br/>utils/]
        end

        subgraph State
            Pinia[Pinia Store<br/>Setup Store Syntax]
            ServerState[Server State<br/>useState]
        end

        subgraph API
            Routes[API Routes<br/>defineEventHandler]
            Fetching[Type-safe Fetch<br/>useFetch]
        end

        subgraph Testing
            ComponentTests[Component Tests]
            StoreTests[Store Tests]
            APITests[API Tests]
            MiddlewareTests[Middleware Tests]
        end
    end

    %% Core Data Flow
    Composables --> Components
    Components --> Layouts
    Layouts --> Pages
    Utils --> Components
    Utils --> Composables

    %% State Management
    Pinia --> Components
    ServerState --> Pages
    ServerState --> API

    %% API Flow
    Routes --> Fetching
    Fetching --> Components
    Fetching --> Pages

    %% Testing
    ComponentTests --> Components
    StoreTests --> Pinia
    APITests --> Routes
    MiddlewareTests --> Pages

    style Composables fill:#bbf,stroke:#333,stroke-width:2px
    style Components fill:#bfb,stroke:#333,stroke-width:2px
    style Pages fill:#fbb,stroke:#333,stroke-width:2px
    style Pinia fill:#fbf,stroke:#333,stroke-width:2px
```

## Definitions

- **Components**: Reusable Vue 3 components using the script setup syntax with proper props and emits
- **Composables**: Reusable functions providing shared logic with proper return types
- **Layouts**: Container components defining the structure of pages with proper slots
- **Pages**: Components representing routes in the application
- **Utils**: Helper functions with proper TypeScript types and JSDoc comments

### Component Structure

Components should follow the single-file component pattern with `<script setup lang="ts">`:

```typescript
<script setup lang="ts">
// Use TypeScript Generics syntax for props
const { loading = false } = defineProps<{
  title: string
  items: Array<{ id: string; name: string }>
  loading?: boolean
}>()

// Use proper emits
const emit = defineEmits<{
  (e: 'select', id: string): void
  (e: 'refresh'): void
}>()

// Use shallowRef instead of ref when possible
const selectedItem = shallowRef<string | null>(null)

// Use computed for derived state
const filteredItems = computed(() => 
  props.items.filter(item => item.name.includes(searchTerm.value))
)

// Use template refs with useTemplateRef
const tableRef = useTemplateRef()

// Handle async data with proper error handling
const { data, error, refresh } = await useAsyncData('items', 
  () => fetchItems(), 
  { onError: (err) => handleError(err) }
)
</script>
```

### Store Management

Pinia stores should use the "Setup Store" syntax:

```typescript
export const useUserStore = defineStore('user', () => {
  // State
  const user = ref(null)
  const isAuthenticated = ref(false)
  
  // Getters (computed)
  const fullName = computed(() => {
    if (!user.value) return ''
    return `${user.value.firstName} ${user.value.lastName}`
  })
  
  // Actions
  async function login(credentials) {
    try {
      const response = await api.login(credentials)
      user.value = response.user
      isAuthenticated.value = true
    } catch (error) {
      createError({ 
        statusCode: 401, 
        message: 'Authentication failed' 
      })
    }
  }
  
  return { 
    user, 
    isAuthenticated, 
    fullName,
    login
  }
})
```

## Code Organization & Best Practices

### General Coding Standards

- Always output full code without placeholders like "// ...existing code..."
- Validate code syntax and nesting before suggesting changes
- Run ESLint and type checking before providing code suggestions
- Use descriptive variable names without abbreviations or acronyms
- Always prefer destructuring whenever possible
- Don't add imports for anything that is auto-imported via Nuxt or compatible packages, e.g. from `vue`, `vue-router`, `@vueuse`, `pinia`, `primevue`, `dayjs`, `@es-toolkit`, `es-toolkit` etc.
- After editing, check for problems (linting, type errors, etc.) and fix them. **Crucially, continue checking and fixing recursively until NO problems remain.** A task is not complete if any problems are reported after a change.
- **Strictly forbid comments explaining refactoring steps or code movement.** Comments like `// Changed from`, `// Updated to`, `// Logic moved to X`, or `// Y is now handled by Z` are unnecessary noise and must not be included in the final code. Focus on code quality and self-documentation. Comments should only explain *why* a complex or non-obvious piece of code exists, not *how* it got there.

### File Organization

- **components/**: Implement components with proper props and emits
- **composables/**: Implement composables with proper return types
- **layouts/**: Implement layouts with proper slots
- **pages/**: Implement pages with proper routing
- **utils/**: Implement utilities with proper types and JSDoc comments
- **tests/**: Place tests for /pages and /layouts here
  - Place tests for other files in the same directory as the file being tested

### Component Development

- Use `<script setup lang="ts">` for single-file components
- Use `defineProps` with TypeScript Generics syntax
- Use `useTemplateRef` for template refs (no explicit typing needed)
- Use `shallowRef` instead of `ref` whenever possible
- Use computed for derived state
- Use provide/inject for dependency injection
- Use watch with immediate option when needed
- Use named slots for component composition
- Type component methods with expose
- Don't use `<style>` blocks unless necessary, always prefer Tailwind CSS classes.

### API Development

- Implement API routes with `defineEventHandler` and zod validation
- Type API responses with `ResT` generic in `useFetch`
- Create type-safe fetch composables
- Handle errors with `createError` and `<NuxtErrorBoundary>`

### State Management

- Store global state in Pinia using `defineStore` and `storeToRefs` with "Setup Store" syntax
- Manage server state with `useState`
- Use `computed` for derived state in components and stores
- Implement store actions with proper typing

### Routing

- Implement middleware with `defineNuxtRouteMiddleware`
- Use `useHead` for dynamic meta updates

### Utilities

- Use Day.js via the `useDayjs` composable for date and time operations
- Use VueUse and es-toolkit for common utilities
- Create reusable transition components
- Create reusable PrimeVue component compositions

## Testing Strategy

### Testing Setup

- Use `~/` syntax for imports in test files
- Use Vitest with `@nuxt/test-utils` for testing
- Use `setup()` from `@nuxt/test-utils` in test files
- Put reusable mocks in `tests/helpers/mocks.ts`
- Put global plugin setup in `tests/helpers/plugins.ts`
- Put PrimeVue component mocks in `tests/helpers/primevue.ts`

### Test File Organization

- Place test files in the same directory as the file being tested (co-located), except for `/pages` and `/layouts`
- Put tests for `/pages` and `/layouts` in their respective directories in `/tests`

### Component Testing

- Test components using `mount` from `@vue/test-utils`
- Use `renderSuspended` for async components
- Mock client-only components with `mockComponent`
- Test form validation error states
- Verify computed property updates
- Test component slot content rendering
- Verify component emits
- Test component lifecycle hooks
- Verify cleanup on unmount

### Store Testing

- Verify Pinia store mutations with `createPinia`
- Test store action side effects
- Verify state management with `@pinia/testing`
- Test store state hydration

### API Testing

- Mock HTTP requests using `vi.mock('ofetch')`
- Mock `useFetch` for API testing
- Test server routes with `createServerComponent`
- Test error states in data fetching

### Middleware and Navigation Testing

- Test middleware with `mockNuxtMiddleware`
- Mock navigation with `mockNavigateTo`
- Verify meta tag updates with `useHead`

### Form Testing

- Test form validation error states
- Test form submission flows
- Test error message displays

### Running Tests

- Run tests with `pnpm vitest run <filename>`

## Error Handling

- Handle errors with `createError` and `<NuxtErrorBoundary>`
- Test error boundary handling
- Verify error message displays
- Test error states in data fetching
